# services/template_service.py
"""Template management service for post-processing."""
import json
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from config import get_settings


@dataclass
class Template:
    """Post-processing template."""
    id: str
    name: str
    description: str
    system_prompt: str
    temperature: float


# Baseline system prompt used by all templates
BASELINE_PROMPT = """You are an expert editor for meeting transcripts. Your task is to post-process a raw transcript generated by an automated speech-to-text model.

The input text suffers from the following specific issues which you must fix:
1. **Hallucinations/Loops:** The model often gets stuck repeating words (e.g., "sim, sim, sim", "da, da, da"). You must aggressively remove these repetitions.
2. **Speaker Fragmentation:** The model incorrectly splits a single sentence across multiple speaker labels (e.g., Speaker 1 starts a sentence, Speaker 2 continues it mid-thought, Speaker 1 finishes it).
3. **Bad Formatting:** The text is broken into very short lines (subtitle format).

**Your Instructions:**
1. **Merge & Clean:** Reconstruct the dialogue flow. If a sentence is split across multiple speaker labels but clearly belongs to one train of thought, merge it into a single paragraph under the speaker who started the thought. Prioritize semantic continuity over the raw speaker labels.
2. **Fix Repetitions:** Remove all stuttering, repeated words, and algorithmic glitches.
3. **Format:** Output the text in clear, readable paragraphs. Do not use short line breaks.
4. **Context:** {context}
5. **Language:** Keep the output in the primary language of the conversation, preserving technical terms and proper nouns.
6. **Output Format:** Return ONLY the cleaned transcript as JSON array. Each element: {{"speaker": "SPEAKER_XX", "text": "cleaned text", "start": timestamp_seconds}}. Preserve the first timestamp of each merged section."""

# Default templates
DEFAULT_TEMPLATES = [
    Template(
        id="it-meeting",
        name="IT Meeting",
        description="Tech standups, sprint reviews, architecture discussions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is a technical IT meeting involving developers and managers. Preserve technical slang (e.g., 'backend', 'frontend', 'feature', 'bug', 'deploy', 'API', 'PR'). Do not over-correct technical terms."
        ),
        temperature=0.2
    ),
    Template(
        id="interview",
        name="Interview",
        description="Job interviews, podcasts, Q&A sessions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is an interview or Q&A session. Preserve the natural back-and-forth flow between interviewer and interviewee. Maintain question-answer structure."
        ),
        temperature=0.3
    ),
    Template(
        id="business-call",
        name="Business Call",
        description="Client calls, sales meetings, professional discussions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is a professional business call or meeting. Preserve formal language and business terminology. Maintain professional tone."
        ),
        temperature=0.2
    ),
]


class TemplateService:
    """Service for managing post-processing templates."""

    def __init__(self, templates_path: Optional[Path] = None):
        if templates_path is None:
            settings = get_settings()
            self.templates_path = settings.templates_path
        else:
            self.templates_path = templates_path

        self._ensure_defaults()

    def _ensure_defaults(self):
        """Ensure default templates exist."""
        self.templates_path.mkdir(parents=True, exist_ok=True)

        for template in DEFAULT_TEMPLATES:
            template_file = self.templates_path / f"{template.id}.json"
            if not template_file.exists():
                self._save_template(template)

    def _save_template(self, template: Template):
        """Save template to disk."""
        template_file = self.templates_path / f"{template.id}.json"
        with open(template_file, "w", encoding="utf-8") as f:
            json.dump({
                "id": template.id,
                "name": template.name,
                "description": template.description,
                "system_prompt": template.system_prompt,
                "temperature": template.temperature,
            }, f, ensure_ascii=False, indent=2)

    def _load_template(self, template_file: Path) -> Optional[Template]:
        """Load template from disk."""
        try:
            with open(template_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            return Template(
                id=data["id"],
                name=data["name"],
                description=data["description"],
                system_prompt=data["system_prompt"],
                temperature=data["temperature"],
            )
        except (json.JSONDecodeError, KeyError, IOError):
            return None

    def list_templates(self) -> List[Template]:
        """List all available templates."""
        templates = []
        for template_file in self.templates_path.glob("*.json"):
            template = self._load_template(template_file)
            if template:
                templates.append(template)
        return sorted(templates, key=lambda t: t.name)

    def get_template(self, template_id: str) -> Optional[Template]:
        """Get a template by ID."""
        template_file = self.templates_path / f"{template_id}.json"
        if template_file.exists():
            return self._load_template(template_file)
        return None

    def create_template(self, template: Template) -> Template:
        """Create a new template."""
        self._save_template(template)
        return template

    def update_template(self, template: Template) -> Template:
        """Update an existing template."""
        self._save_template(template)
        return template

    def delete_template(self, template_id: str) -> bool:
        """Delete a template. Returns True if deleted, False if not found or is default."""
        # Prevent deleting default templates
        if template_id in [t.id for t in DEFAULT_TEMPLATES]:
            return False

        template_file = self.templates_path / f"{template_id}.json"
        if template_file.exists():
            template_file.unlink()
            return True
        return False
