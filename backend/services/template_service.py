# services/template_service.py
"""Template management service for post-processing."""
import json
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from config import get_settings


@dataclass
class Template:
    """Post-processing template."""
    id: str
    name: str
    description: str
    system_prompt: str
    temperature: float


# Baseline system prompt used by all templates
BASELINE_PROMPT = """You are an expert editor for meeting transcripts. Your task is to post-process a raw transcript generated by an automated speech-to-text model.

## INPUT FORMAT
Each line: [HH:MM:SS] SPEAKER_XX: text

## CRITICAL RULES

1. **PRESERVE ORIGINAL LANGUAGE**: The transcript MUST remain in the SAME language as the input. NEVER translate. If input is Russian, output is Russian. If input is English, output is English. If input is mixed, keep the mix.
2. **MINIMAL CHANGES**: Only fix obvious ASR errors. Do NOT rephrase, do NOT paraphrase, do NOT "improve" wording. Keep the speaker's original words as much as possible.
3. **PRESERVE TIMESTAMPS**: When merging multiple lines into one, use the timestamp of the FIRST line being merged.
4. **NEVER INVENT TIMESTAMPS**: Only use timestamps that exist in the input.
5. **MAINTAIN ORDER**: Output timestamps must be in chronological order.

## PROBLEMS TO FIX (and ONLY these)

1. **Hallucinations/Loops**: Remove repeated words (e.g., "da, da, da", "sim, sim, sim", "ну ну ну")
2. **Speaker Fragmentation**: Merge sentences incorrectly split across speakers
3. **Bad Formatting**: Convert short subtitle-style lines into paragraphs
4. **Punctuation**: Add proper punctuation where missing

## WHAT NOT TO CHANGE

- Do NOT translate any words
- Do NOT change word choice or vocabulary
- Do NOT rewrite sentences in "better" form
- Do NOT add words that weren't spoken
- Do NOT remove filler words like "ну", "вот", "типа", "like", "you know" unless excessive

## PROCESSING INSTRUCTIONS

1. **Merge**: If consecutive lines form one thought, merge them under the first speaker, keeping the FIRST timestamp
2. **Clean**: Remove ONLY stuttering, repetitions, algorithmic glitches
3. **Format**: Create readable paragraphs with proper punctuation
4. **Context**: {context}
5. **Language**: Output MUST be in the same language as input

## SPEAKER IDENTIFICATION

Analyze the conversation to identify speakers by their names and roles. Look for:
- Direct addressing: "Привет, Андрей", "Лена, покажи...", "Thanks, Mike"
- Self-introduction: "Меня зовут...", "Это Сергей", "I'm John"
- Role indicators from context: discusses code → developer, discusses design → designer, asks about deadlines → manager

Available roles for this context: {role_context}

## OUTPUT FORMAT (STRICT JSON)

Return a JSON object with two keys: "segments" and "speaker_suggestions".

```json
{{{{
  "segments": [
    {{{{"speaker": "SPEAKER_00", "text": "cleaned text", "start": 120}}}}
  ],
  "speaker_suggestions": [
    {{{{
      "speaker_id": "SPEAKER_00",
      "name": "Лена",
      "name_confidence": 0.9,
      "name_reason": "SPEAKER_01 said 'Лена, покажи макеты'",
      "role": "designer",
      "role_confidence": 0.85,
      "role_reason": "Discusses UI, mockups, visual design"
    }}}}
  ]
}}}}
```

Rules for speaker_suggestions:
- Include ALL speakers from input, even if name/role unknown
- If name unknown: "name": null, "name_confidence": 0, "name_reason": null
- If role unknown: "role": null, "role_confidence": 0, "role_reason": null
- confidence is 0.0 to 1.0
- reason should quote or describe the evidence

## SELF-CHECK BEFORE RETURNING

Before returning your answer, verify:
1. All timestamps are numbers (seconds), not strings
2. Timestamps are in ascending order
3. All speaker IDs match the input format (SPEAKER_XX)
4. speaker_suggestions includes every speaker from input
5. confidence values are between 0.0 and 1.0

Return ONLY the JSON object, no explanations."""

# Default templates
DEFAULT_TEMPLATES = [
    Template(
        id="it-meeting",
        name="IT Meeting",
        description="Tech standups, sprint reviews, architecture discussions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is a technical IT meeting involving developers and managers. Preserve technical slang (e.g., 'backend', 'frontend', 'feature', 'bug', 'deploy', 'API', 'PR'). Do not over-correct technical terms.",
            role_context="developer, designer, QA, DevOps, manager, product owner, team lead, architect"
        ),
        temperature=0.2
    ),
    Template(
        id="interview",
        name="Interview",
        description="Job interviews, podcasts, Q&A sessions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is an interview or Q&A session. Preserve the natural back-and-forth flow between interviewer and interviewee. Maintain question-answer structure.",
            role_context="interviewer, candidate, HR manager, recruiter, host, guest"
        ),
        temperature=0.3
    ),
    Template(
        id="business-call",
        name="Business Call",
        description="Client calls, sales meetings, professional discussions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is a professional business call or meeting. Preserve formal language and business terminology. Maintain professional tone.",
            role_context="client, sales manager, account manager, consultant, CEO, CFO, director, partner"
        ),
        temperature=0.2
    ),
]


class TemplateService:
    """Service for managing post-processing templates."""

    def __init__(self, templates_path: Optional[Path] = None):
        if templates_path is None:
            settings = get_settings()
            self.templates_path = settings.templates_path
        else:
            self.templates_path = templates_path

        self._ensure_defaults()

    def _ensure_defaults(self):
        """Ensure default templates exist."""
        self.templates_path.mkdir(parents=True, exist_ok=True)

        for template in DEFAULT_TEMPLATES:
            template_file = self.templates_path / f"{template.id}.json"
            if not template_file.exists():
                self._save_template(template)

    def _save_template(self, template: Template):
        """Save template to disk."""
        template_file = self.templates_path / f"{template.id}.json"
        with open(template_file, "w", encoding="utf-8") as f:
            json.dump({
                "id": template.id,
                "name": template.name,
                "description": template.description,
                "system_prompt": template.system_prompt,
                "temperature": template.temperature,
            }, f, ensure_ascii=False, indent=2)

    def _load_template(self, template_file: Path) -> Optional[Template]:
        """Load template from disk."""
        try:
            with open(template_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            return Template(
                id=data["id"],
                name=data["name"],
                description=data["description"],
                system_prompt=data["system_prompt"],
                temperature=data["temperature"],
            )
        except (json.JSONDecodeError, KeyError, IOError):
            return None

    def list_templates(self) -> List[Template]:
        """List all available templates."""
        templates = []
        for template_file in self.templates_path.glob("*.json"):
            template = self._load_template(template_file)
            if template:
                templates.append(template)
        return sorted(templates, key=lambda t: t.name)

    def get_template(self, template_id: str) -> Optional[Template]:
        """Get a template by ID."""
        template_file = self.templates_path / f"{template_id}.json"
        if template_file.exists():
            return self._load_template(template_file)
        return None

    def create_template(self, template: Template) -> Template:
        """Create a new template."""
        self._save_template(template)
        return template

    def update_template(self, template: Template) -> Template:
        """Update an existing template."""
        self._save_template(template)
        return template

    def delete_template(self, template_id: str) -> bool:
        """Delete a template. Returns True if deleted, False if not found or is default."""
        # Prevent deleting default templates
        if template_id in [t.id for t in DEFAULT_TEMPLATES]:
            return False

        template_file = self.templates_path / f"{template_id}.json"
        if template_file.exists():
            template_file.unlink()
            return True
        return False
