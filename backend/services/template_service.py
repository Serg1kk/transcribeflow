# services/template_service.py
"""Template management service for post-processing."""
import json
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from config import get_settings


@dataclass
class Template:
    """Post-processing template."""
    id: str
    name: str
    description: str
    system_prompt: str
    temperature: float


# Baseline system prompt used by all templates
BASELINE_PROMPT = """You are an expert editor for meeting transcripts. Your task is to post-process a raw transcript generated by an automated speech-to-text model.

## INPUT FORMAT
Each line: [HH:MM:SS] SPEAKER_XX: text

## CRITICAL RULES FOR TIMESTAMPS

1. **PRESERVE TIMESTAMPS**: When merging multiple lines into one, use the timestamp of the FIRST line being merged.
2. **NEVER INVENT TIMESTAMPS**: Only use timestamps that exist in the input.
3. **MAINTAIN ORDER**: Output timestamps must be in chronological order.

## PROBLEMS TO FIX

1. **Hallucinations/Loops**: Remove repeated words (e.g., "da, da, da", "sim, sim, sim")
2. **Speaker Fragmentation**: Merge sentences incorrectly split across speakers
3. **Bad Formatting**: Convert short subtitle-style lines into paragraphs

## PROCESSING INSTRUCTIONS

1. **Merge**: If consecutive lines form one thought, merge them under the first speaker, keeping the FIRST timestamp
2. **Clean**: Remove stuttering, repetitions, algorithmic glitches
3. **Format**: Create readable paragraphs
4. **Context**: {context}
5. **Language**: Keep original language, preserve technical terms

## OUTPUT FORMAT (STRICT JSON)

Return a JSON array. Each element MUST have exactly these fields:
- "speaker": string (SPEAKER_00, SPEAKER_01, etc. - DO NOT change these IDs)
- "text": string (cleaned merged text)
- "start": number (timestamp in SECONDS - from FIRST merged segment)

Example:
Input:
[00:02:00] SPEAKER_01: We need to
[00:02:01] SPEAKER_02: fix the bug
[00:02:02] SPEAKER_01: in production.
[00:02:04] SPEAKER_01: Da, da, da.
[00:02:30] SPEAKER_02: Next topic.

Output:
[
  {{"speaker": "SPEAKER_01", "text": "We need to fix the bug in production.", "start": 120}},
  {{"speaker": "SPEAKER_02", "text": "Next topic.", "start": 150}}
]

Note: 00:02:00 = 120 seconds, 00:02:30 = 150 seconds

## SELF-CHECK BEFORE RETURNING

Before returning your answer, verify:
1. All timestamps are numbers (seconds), not strings
2. Timestamps are in ascending order
3. No timestamp is larger than the last input timestamp
4. All speaker IDs match the input format (SPEAKER_XX)

Return ONLY the JSON array, no explanations."""

# Default templates
DEFAULT_TEMPLATES = [
    Template(
        id="it-meeting",
        name="IT Meeting",
        description="Tech standups, sprint reviews, architecture discussions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is a technical IT meeting involving developers and managers. Preserve technical slang (e.g., 'backend', 'frontend', 'feature', 'bug', 'deploy', 'API', 'PR'). Do not over-correct technical terms."
        ),
        temperature=0.2
    ),
    Template(
        id="interview",
        name="Interview",
        description="Job interviews, podcasts, Q&A sessions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is an interview or Q&A session. Preserve the natural back-and-forth flow between interviewer and interviewee. Maintain question-answer structure."
        ),
        temperature=0.3
    ),
    Template(
        id="business-call",
        name="Business Call",
        description="Client calls, sales meetings, professional discussions",
        system_prompt=BASELINE_PROMPT.format(
            context="This is a professional business call or meeting. Preserve formal language and business terminology. Maintain professional tone."
        ),
        temperature=0.2
    ),
]


class TemplateService:
    """Service for managing post-processing templates."""

    def __init__(self, templates_path: Optional[Path] = None):
        if templates_path is None:
            settings = get_settings()
            self.templates_path = settings.templates_path
        else:
            self.templates_path = templates_path

        self._ensure_defaults()

    def _ensure_defaults(self):
        """Ensure default templates exist."""
        self.templates_path.mkdir(parents=True, exist_ok=True)

        for template in DEFAULT_TEMPLATES:
            template_file = self.templates_path / f"{template.id}.json"
            if not template_file.exists():
                self._save_template(template)

    def _save_template(self, template: Template):
        """Save template to disk."""
        template_file = self.templates_path / f"{template.id}.json"
        with open(template_file, "w", encoding="utf-8") as f:
            json.dump({
                "id": template.id,
                "name": template.name,
                "description": template.description,
                "system_prompt": template.system_prompt,
                "temperature": template.temperature,
            }, f, ensure_ascii=False, indent=2)

    def _load_template(self, template_file: Path) -> Optional[Template]:
        """Load template from disk."""
        try:
            with open(template_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            return Template(
                id=data["id"],
                name=data["name"],
                description=data["description"],
                system_prompt=data["system_prompt"],
                temperature=data["temperature"],
            )
        except (json.JSONDecodeError, KeyError, IOError):
            return None

    def list_templates(self) -> List[Template]:
        """List all available templates."""
        templates = []
        for template_file in self.templates_path.glob("*.json"):
            template = self._load_template(template_file)
            if template:
                templates.append(template)
        return sorted(templates, key=lambda t: t.name)

    def get_template(self, template_id: str) -> Optional[Template]:
        """Get a template by ID."""
        template_file = self.templates_path / f"{template_id}.json"
        if template_file.exists():
            return self._load_template(template_file)
        return None

    def create_template(self, template: Template) -> Template:
        """Create a new template."""
        self._save_template(template)
        return template

    def update_template(self, template: Template) -> Template:
        """Update an existing template."""
        self._save_template(template)
        return template

    def delete_template(self, template_id: str) -> bool:
        """Delete a template. Returns True if deleted, False if not found or is default."""
        # Prevent deleting default templates
        if template_id in [t.id for t in DEFAULT_TEMPLATES]:
            return False

        template_file = self.templates_path / f"{template_id}.json"
        if template_file.exists():
            template_file.unlink()
            return True
        return False
